}
fx <- cbind(dbeta(x, a,b), pbeta(x, a,b), qbeta(x, a,b))
f <- fx; f[fx == Inf] <- 1e100
matplot(x, f, ylab="", type="l", ylim=ylim, asp=asp,
main = sprintf("[dpq]beta(x, a=%g, b=%g)", a,b))
abline(0,1,     col="gray", lty=3)
abline(h = 0:1, col="gray", lty=3)
legend("top", paste0(c("d","p","q"), "beta(x, a,b)"),
col=1:3, lty=1:3, bty = "n")
invisible(cbind(x, fx))
}
pl.beta(2,2)
plot(sort(beta_ar), main="Valori generati da Beta(2,2)", pch=".")
curve(qbeta(x, 2, 2), add = TRUE, col = "red")
qbeta(x, 2, 2)
curve(qbeta(x, 2, 2), add = TRUE, col = "red")
qbeta
beta_f <- function(x) {
return( ( gamma(4) / ( gamma(2)*gamma(2) ) ) * x * (1-x) )
}
beta_ar <- r.acc.rif(10000,
beta_f,
dunif,
runif,
1.5)
plot(sort(beta_ar), main="Valori generati da Beta(2,2)", pch=".")
curve(qbeta(x, 2, 2), add = TRUE, col = "red")
plot(qbeta(x, 2, 2))
plot(sort(beta_ar), main="Valori generati da Beta(2,2)", pch=".")
plot(qbeta(x, 2, 2), add = TRUE, col = "red", )
test_vect <- seq(0, 1, length.out=10000)
plot(sort(beta_ar), main="Valori generati da Beta(2,2)", pch=".")
curve(qbeta(test_vect, 2, 2), add = TRUE, col = "red")
curve(qbeta(test_vect, 2, 2), add = TRUE, col = "red", lty=1)
qbeta(test_vect, 0, 1)
test_vect
qbeta(test_vect, 2, 2)
?plot
plot(type="n", main="Bontà adattamento generazione Beta(2,2)")
plot(0, 1, type="n", main="Bontà adattamento generazione Beta(2,2)")
plot(0, type="n", main="Bontà adattamento generazione Beta(2,2)")
, 1
plot(0, 1, type="n", main="Bontà adattamento generazione Beta(2,2)")
points(sort(beta_ar), pch=".")
plot(0, 1, type="n", main="Bontà adattamento generazione Beta(2,2)")
points(sort(beta_ar), pch=".", add = TRUE)
curve(sort(beta_ar), lwd = 1, add = TRUE)
curve(sort(beta_ar), lwd = 1)
points(sort(beta_ar), pch=".")
plot(0, 1, type="n", main="Bontà adattamento generazione Beta(2,2)")
points(sort(beta_ar), pch=".")
plot(0, 1, type="n", main="Bontà adattamento generazione Beta(2,2)")
points(sort(beta_ar), pch=".")
plot(sort(beta_ar))
plot(sort(beta_ar), pch=".")
curve(qbeta(test_vect, 2, 2), add = TRUE)
qbeta(test_vect, 2, 2)
plot(qbeta(test_vect, 2, 2))
plot(qbeta(test_vet, 2,2), pch=".")
curve(sort(beta_ar), add = TRUE)
?curve
?points
plot(0, 1, type=n)
points(sort(beta_ar), pch=".")
plot(0, 1, type="n")
points(sort(beta_ar), pch=".")
points(sort(beta_ar), pch=".")
points(sort(beta_ar), pch=".", add=TRUE)
hist(beta_ar)
hist(beta_ar, prob=TRUE, nclass=50)
hist(beta_ar, prob=TRUE, nclass=100)
curve(beta_f(x), add=TRUE, col="red", lwd=2)
responenziale <- function(lambda = 1, p){
return(qesponenziale(lambda, p))
}
valori <- responenziale(runif(10000))
desponenziale <- function(lambda= 1, y) {
return( exp(-lambda*y) )
}
pesponenziale <- function(lambda = 1, y) {
return( 1 - exp(-lambda*y) )
}
qesponenziale <- function(lambda = 1, p) {
res = - (log(1-p) / lambda)
return(res)
}
responenziale <- function(lambda = 1, p){
return(qesponenziale(lambda, p))
}
valori <- responenziale(runif(10000))
responenziale <- function(lambda, p){
return(qesponenziale(lambda, p))
}
valori <- responenziale(runif(10000))
responenziale <- function(lambda, p){
return(qesponenziale(lambda, p))
}
valori <- responenziale(1, runif(10000))
# probability-probability plot
plot(ecdf(valori))
curve(pexp, add= TRUE, col="red")
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale(1),
1)
responenziale <- function(lambda = 1, p){
return(qesponenziale(lambda, p))
}
valori <- responenziale(1, runif(10000))
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
responenziale <- function(lambda = 1, p){
return(qesponenziale(p))
}
valori <- responenziale(1, runif(10000))
desponenziale <- function(y, lambda = 1) {
return( exp(-lambda*y) )
}
pesponenziale <- function(y, lambda = 1) {
return( 1 - exp(-lambda*y) )
}
qesponenziale <- function(p, lambda = 1) {
res = - (log(1-p) / lambda)
return(res)
}
responenziale <- function(p, lambda = 1){
return(qesponenziale(p))
}
valori <- responenziale(runif(10000))
# probability-probability plot
plot(ecdf(valori))
curve(pexp, add= TRUE, col="red")
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
normale_troncata <- function(x){
return( ( 2 / sqrt(2*pi) ) * exp(- (x^2) /2) )
}
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
plot(normale_troncata(x), lwd = 2)
curve(desponenziale(x), lty = 2, col = "red")
plot(normale_troncata(x), lwd = 2)
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, do.points = FALSE)
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, type="l")
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, type="l", xlim=c(0, 1), ylim=c(0,10))
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, type="l", xlim=c(0, 100), ylim=c(0,1))
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, type="l", xlim=c(0, 10), ylim=c(0,1))
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
plot(normale_troncata(x), lwd = 2, type="l")
curve(desponenziale(x), lty = 2, col = "red", add = TRUE)
curve(normale_troncata(x), 0, 5, lwd = 2)
curve(desponenziale(x), 0, 5, lty = 2, col = "red", add = TRUE)
k <- 2/sqrt(2*pi)
k <- 2/sqrt(2*pi)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
k)
curve(k*desponenziale(x), 0, 5, lty = 2, col = "red")
curve(normale_troncata(x), 0, 5, lwd = 2, add=TRUE)
plot(ecdf(normale_tronc_ar))
plot(ecdf(normale_tronc_ar))
plot(ecdf(normale_tronc_ar), xlim=c(0, 10))
normale_tronc_ar
normale_troncata <- function(x){
return( ( 2 / sqrt(2*pi) ) * exp(- (x^2) /2) )
}
normale_troncata(0)
2/sqrt(2*pi)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
normale_tronc_ar
normale_troncata <- function(x){
return( ( 2 / sqrt(2*pi) ) * exp(- (x^2) /2) )
}
k <- 2/sqrt(2*pi)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
dexp,
rexp,
1)
normale_tronc_ar
responenziale <- function(p, lambda = 1){
return(qesponenziale(p, lambda))
}
valori <- responenziale(runif(10000))
# probability-probability plot
plot(ecdf(valori))
curve(pexp, add= TRUE, col="red")
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
1)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
k)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
dexp,
rexp,
k)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
dexp,
rexp,
1)
curve(k*desponenziale(x), 0, 5, lty = 2, col = "red")
curve(normale_troncata(x), 0, 5, lwd = 2, add=TRUE)
k <- (2/sqrt(2*pi))*exp(0.5)
curve(k*desponenziale(x), 0, 5, lty = 2, col = "red")
curve(normale_troncata(x), 0, 5, lwd = 2, add=TRUE)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
dexp,
rexp,
k)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
rexp,
k)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
k)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
qesponenziale,
k)
responenziale <- function(n, lambda = 1){
return(qesponenziale(runif(n), lambda))
}
valori <- responenziale(runif(10000))
k <- (2/sqrt(2*pi))*exp(0.5)
normale_tronc_ar <- r.acc.rif(10000,
normale_troncata,
desponenziale,
responenziale,
k)
plot(ecdf(normale_tronc_ar), pch=".")
normale_trasf_polare <- function(u1, u2){
r <- sqrt(-2*log(u1))
theta <- 2*pi*u2
x <- r*cos(theta)
y <- r*sin(theta)
return(list(x=x, y=y))
}
normale_trasf_polare(runif(10), runif(10))
normale_polare <- normale_trasf_polare(runif(10000), runif(10000))
# Verifica di X
hist(normale_polare$x, prob = TRUE, nclass = 100)
curve(dnorm(x), col="red", lwd=2, add = TRUE)
# Verifica di Y
hist(normale_polare$y, prob = TRUE, nclass = 100)
curve(dnorm(x), col="red", lwd=2, add = TRUE)
plot(normale_polare)
plot(normale_polare, pch=".")
normale_polare <- normale_trasf_polare(runif(100000), runif(100000))
plot(normale_polare, pch=".")
rm(list=ls())
library(remotes)
install.packages("remotes")
library(remotes)
install_github("JustinMShea/ExpectedReturns")
R CMD BUILD --no-lock ExpectedReturns
R CMD build --no-lock ExpectedReturns
CMD build --no-lock ExpectedReturns
build --no-lock ExpectedReturns
install_github("JustinMShea/ExpectedReturns", build_opts=c("--no-lock"))
install_github("JustinMShea/ExpectedReturns", build_opts=c("--no-lock"), force=TURE)
install_github("JustinMShea/ExpectedReturns", build_opts=c("--no-lock"), force=TRUE)
install_github("JustinMShea/FactorAnalytics")
?install_github
install_github("JustinMShea/ExpectedReturns", build_opts=c("--no-lock"), force=TRUE, build_vignettes = TRUE)
install_github("JustinMShea/ExpectedReturns", force=TRUE, build_vignettes = TRUE)
install_github("JustinMShea/ExpectedReturns", force=TRUE, build_vignettes = TRUE, build = FALSE)
install_github("JustinMShea/FactorAnalytics", force = TRUE, build_vignettes = TRUE, build = FALSE)
uninstall.packages(c("FactorAnalytics", "ExpectedReturns"))
remove.packages(c("FactorAnalytics", "ExpectedReturns"))
install_github("JustinMShea/ExpectedReturns", build_vignettes = TRUE)
install_github("JustinMShea/ExpectedReturns", build_vignettes = TRUE, build=FALSE)
vignette(package="ExpectedReturns")
vignette(package="FactorAnalytics")
build("ExpectedReturns")
remove.packages(c("FactorAnalytics", "ExpectedReturns"))
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
install.packages("devtools")
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
Sys.which("make")
writeLines(strsplit(Sys.getenv("PATH"), ";")[[1]])
library(devtools)
Sys.setenv(PATH = paste("C:/Rtools/bin", Sys.getenv("PATH"), sep=";"))
Sys.setenv(PATH = paste("C:/Rtools/bin", Sys.getenv("PATH"), sep=";"))
Sys.which("make")
Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")
Sys.which("make")
Sys.which("make")
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
install.packages('R.rsp')
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
usethis::create_github_token()
usethis::edit_r_environ()
rm(list=ls())
devtools::install_github(JustinMShea/ExpectedReturns", build_vignettes=TRUE)
?devtools::install_github
devtools::install_github(JustinMShea/ExpectedReturns", build_vignettes=TRUE)
library(devtools)
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
install.packages("knitr")
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
install.packages("rmarkdown")
devtools::install_github("JustinMShea/ExpectedReturns", build_vignettes=TRUE)
install.packages("render")
molte.t <- function(n, rf, mu, B = 10000) {
y <- matrix(rf(n * B), n, B) # Ogni colonna della matrice rappresenta
# un campione, di numerosita' n, dalla
# v.c. Y.
ybar <- apply(y, 2, mean) # B medie campionarie osservate. L'argomento "2" significa che
# la funzione ("mean", in questo caso) deve essere applicata alle
# colonne (con "1" viene applicata alle righe).
s <- apply(y, 2, sd) # B dev. stand. campionarie osservate.
sqrt(n) * (ybar - mu)/s
}
test <- molte.t(5, runif, 0.5)
test
test <- molte.t(100, runif, 0.5)
length(test)
conta.t <- function(n, rf, mu, B = 10000, alpha = c(0.01,0.05, 0.1)) {
tn <- molte.t(n, rf, mu, B) # creo vettore di lunghezza B di "medie campionarie
# standardizzate"
# definisco i quantili per i rispettivi livelli di significatività (in questo caso sono
# dei vettori)
zbasso <- qnorm(alpha)
zalto <- -zbasso
zbil <- qnorm(1 - alpha/2)
# inizializzo 3 vettori di lunghezza pari al numero di livelli di significatività
# che vogliamo testare
basso <- alto <- bil <- rep(0, length(alpha))
for (i in 1:length(alpha)) {
basso[i] <- mean(tn <= zbasso[i])
alto[i] <- mean(tn >= zalto[i])
bil[i] <- mean((tn <= -zbil[i]) | (tn >= zbil[i]))
}
# inserisco le risposte in una lista, dove ogni elemento è una matrice
# che contiene i livelli nominali, quelli osservati e la variabilità
# stimata dello stimatore
ans <- list()
ans$basso <- cbind(alpha, basso, sqrt(basso * (1 - basso)/B))
colnames(ans$basso) <- c("alpha", "psi", "se")
ans$alto <- cbind(alpha, alto, sqrt(alto * (1 - alto)/B))
colnames(ans$alto) <- c("alpha", "psi", "se")
ans$bilaterale <- cbind(alpha, bil, sqrt(bil * (1 - bil)/B))
colnames(ans$bilaterale) <- c("alpha", "psi", "se")
ans
}
# Dati uniformi.
conta.t(5, runif, 0.5)
conta.t(30, runif, 0.5)
conta.t(100, runif, 0.5)
# Dati esponenziali.
conta.t(5, rexp, 1)   # Almeno per n piccolo, l'approssimazione sulla
conta.t(30, rexp, 1)  # coda sinistra e' molto peggiore di quella che si
conta.t(100, rexp, 1) # otteneva per dati uniformi.
curve(dexp(x), 0, 4) # Guardando la densita' di una esponenziale,
# ci accorgiamo perche'.
# Per paragonare gli istogrammi alle densita', usiamo prob = TRUE.
# In questo modo le aree dei rettangoli rappresentano le frequenze
# relative delle classi corrispondenti. In altri termini, la somma
# delle aree dei rettangoli e' pari ad 1, come l'area sotto la
# densita'. Senza prob = TRUE, l'istogramma rappresenterebbe le
# frequenze assolute con le altezze dei rettangoli.
hist(molte.t(10, runif, 0.5), nclass = 40, prob = TRUE)
curve(dnorm(x), -4, 4, col = "red", add = TRUE)
qqnorm(molte.t(10, runif, 0.5)) # Q-Q plot per la normalita'.
abline(0,1,col="blue",lwd=2)
hist(molte.t(30, runif, 0.5), nclass = 40, prob = TRUE) # Aumentiamo n.
curve(dnorm(x), -4, 4, col = "red", add = TRUE)
qqnorm(molte.t(30, runif, 0.5))
abline(0,1,col="blue",lwd=2)
hist(molte.t(10, rexp, 1), nclass = 40, prob = TRUE) # Cambiamo distribuzione.
curve(dnorm(x), -4, 4, col = "red", add = TRUE)
qqnorm(molte.t(10, rexp, 1))
abline(0,1,col="blue",lwd=2)
curve(dnorm(x, 2, 1), col="red")
curve(dnorm(x))
curve(dnorm(x, 2, 1), col="red")
curve(dnorm(x), -4, 4)
curve(dnorm(x, 2, 1), col="red", add = TRUE, -4, 4)
curve(dnorm(x), -5, 5)
curve(dnorm(x, 2, 1), col="red", add = TRUE, -5, 5)
curve(dnorm(x), -5, 5) # H_0: mu = 0
curve(dnorm(x, 1, 1), col="red", add = TRUE, -5, 5) # H_1: mu = 1
conta.t.potenza(30, rmorm, 0, 1)
molte.t.potenza <- function(n, rf, mu_0, mu_1, B = 10000) {
y <- matrix(rf(n * B, mu_1), n, B) # Ogni colonna della matrice rappresenta
# un campione, di numerosita' n, dalla
# v.c. Y.
ybar <- apply(y, 2, mean) # B medie campionarie osservate. L'argomento "2" significa che
# la funzione ("mean", in questo caso) deve essere applicata alle
# colonne (con "1" viene applicata alle righe).
s <- apply(y, 2, sd) # B dev. stand. campionarie osservate.
sqrt(n) * (ybar - mu_0)/s # restituisce vettore di lunghezza B
}
conta.t.potenza <- function(n, rf, mu_0, mu_1, B = 10000, alpha = c(0.01,0.05, 0.1)) {
tn <- molte.t(n, rf, mu_0, mu_1, B) # creo vettore di lunghezza B di "medie campionarie
# standardizzate"
# definisco i quantili per i rispettivi livelli di significatività (in questo caso sono
# dei vettori)
zbasso <- qnorm(alpha)
zalto <- -zbasso
zbil <- qnorm(1 - alpha/2)
# inizializzo 3 vettori di lunghezza pari al numero di livelli di significatività
# che vogliamo testare
basso <- alto <- bil <- rep(0, length(alpha))
for (i in 1:length(alpha)) {
basso[i] <- mean(tn <= zbasso[i])
alto[i] <- mean(tn >= zalto[i])
bil[i] <- mean((tn <= -zbil[i]) | (tn >= zbil[i]))
}
# inserisco le risposte in una lista, dove ogni elemento è una matrice
# che contiene i livelli nominali, quelli osservati e la variabilità
# stimata dello stimatore
ans <- list()
ans$basso <- cbind(alpha, basso, sqrt(basso * (1 - basso)/B))
colnames(ans$basso) <- c("alpha", "psi", "se")
ans$alto <- cbind(alpha, alto, sqrt(alto * (1 - alto)/B))
colnames(ans$alto) <- c("alpha", "psi", "se")
ans$bilaterale <- cbind(alpha, bil, sqrt(bil * (1 - bil)/B))
colnames(ans$bilaterale) <- c("alpha", "psi", "se")
ans
}
curve(dnorm(x), -5, 5) # H_0: mu = 0
curve(dnorm(x, 1, 1), col="red", add = TRUE, -5, 5) # H_1: mu = 1
conta.t.potenza(30, rmorm, 0, 1)
molte.t.potenza <- function(n, rf, mu_0, mu_1, B = 10000) {
y <- matrix(rf(n * B, mu_1), n, B) # Ogni colonna della matrice rappresenta
# un campione, di numerosita' n, dalla
# v.c. Y.
ybar <- apply(y, 2, mean) # B medie campionarie osservate. L'argomento "2" significa che
# la funzione ("mean", in questo caso) deve essere applicata alle
# colonne (con "1" viene applicata alle righe).
s <- apply(y, 2, sd) # B dev. stand. campionarie osservate.
sqrt(n) * (ybar - mu_0)/s # restituisce vettore di lunghezza B
}
conta.t.potenza <- function(n, rf, mu_0, mu_1, B = 10000, alpha = c(0.01,0.05, 0.1)) {
tn <- molte.t.potenza(n, rf, mu_0, mu_1, B) # creo vettore di lunghezza B di "medie campionarie
# standardizzate"
# definisco i quantili per i rispettivi livelli di significatività (in questo caso sono
# dei vettori)
zbasso <- qnorm(alpha)
zalto <- -zbasso
zbil <- qnorm(1 - alpha/2)
# inizializzo 3 vettori di lunghezza pari al numero di livelli di significatività
# che vogliamo testare
basso <- alto <- bil <- rep(0, length(alpha))
for (i in 1:length(alpha)) {
basso[i] <- mean(tn <= zbasso[i])
alto[i] <- mean(tn >= zalto[i])
bil[i] <- mean((tn <= -zbil[i]) | (tn >= zbil[i]))
}
# inserisco le risposte in una lista, dove ogni elemento è una matrice
# che contiene i livelli nominali, quelli osservati e la variabilità
# stimata dello stimatore
ans <- list()
ans$basso <- cbind(alpha, basso, sqrt(basso * (1 - basso)/B))
colnames(ans$basso) <- c("alpha", "psi", "se")
ans$alto <- cbind(alpha, alto, sqrt(alto * (1 - alto)/B))
colnames(ans$alto) <- c("alpha", "psi", "se")
ans$bilaterale <- cbind(alpha, bil, sqrt(bil * (1 - bil)/B))
colnames(ans$bilaterale) <- c("alpha", "psi", "se")
ans
}
curve(dnorm(x), -5, 5) # H_0: mu = 0
curve(dnorm(x, 1, 1), col="red", add = TRUE, -5, 5) # H_1: mu = 1
conta.t.potenza(30, rmorm, 0, 1)
conta.t.potenza(30, rnorm, 0, 1)
?par
x = 1:3
outer(x,x)
setwd("C:/Users/alexc/rproj/rejection-sampling")
